## 이 리포지토리의 목적 

이 리포지토리는 다음 두 실험을 위한 프로그램을 작성하기 위한 리포지토리이다. 

1. TCP를 사용할 때, 보내는 데이터의 단위에 따라 전송하는 데 걸리는 시간이 얼마나 걸리는 지 측정한다.

2. UDP를 사용할 때, 보내는 데이터의 단위에 따라 에러가 발생하는 정도는 어떻게 변화하는 지 측정한다.

두 실험 모두, 전송하는 데이터의 단위를 500바이트에서 65535바이트까지 변화시켜가며 
1GB의 데이터를 전송한다. 

이상의 실험을 위해 TCP 클라이언트와 서버, UDP 클라이언트와 서버를 제작한다.

## 테스트 환경을 위한 유틸리티 클래스 

TCP 테스트와 UDP 테스트 양쪽에서 공통으로 사용할 정적 유틸리티 메소드를 가질 
유틸리티 클래스들을 정의한다. 

코드의 재사용성을 높여 환경 통제를 쉽게하기 위함이다.

공통으로 사용될 로직은 아래와 같다. 

1. 테스트용 데이터 단위 반환 
2. 서버 주소와 포트 번호 입력 
3. 시간 측정 
4. 실험 결과 파일 출력 

(상세 코드는 리포지토리 참조)

```java
package org.limdongha.util;
//......
/**
 * 테스트를 위해 사용할 정적 유틸 클래스
 * @author limdongha
 */
public class TestUtils {
    //......
}
```

```java
package org.limdongha.util;
//......
/**
 * 시간 측정을 위한 클래스
 * @author limdongha
 */
public class Timer {
    //......
}

```

```java
package org.limdongha.util;
//......

/**
 * CSV 파일을 편리하게 작성하기 위한 클래스 <br/>
 * write 할 모든 클래스는 CsvConvertible 을 구현하고,
 * 열의 갯수가 일치해야 하며, 열 이름을 반환할 수 있어야 한다. (열 이름 일치는 검사하지 않음)
 * @author limdongha
 */
public class CsvWriter<T extends CsvConvertible> implements Closeable, AutoCloseable, Flushable {
    //......
}
```


## TCP

### 실험 목적과 예상 

어플리케이션에서 TCP 소켓으로 보내는 데이터의 단위가 전송 속도에 어떠한 영향을 미치는 지 
측정해본다. 

먼저 데이터의 단위 크기가 속도에 미치는 영향들을 예상해보자.

1. 데이터가 작을 경우
   - TCP와 IP의 헤더 파일이 전체 패킷에서 차지하는 비율이 상대적으로 커질 것이다. (오버헤드)
   - 대역폭을 효율적으로 사용하지 못할 가능성이 높다.
   - 어플리케이션에서 전송을 요청하는 횟수가 증가하므로 CPU 사용량이 더 높을 것이다. 
   - ACK 패킷 수가 증가로 인한 오버헤드가 생긴다. 
   - IP 파편화가 발생할 가능성이 낮아진다. 
2. 데이터가 클 경우 
   - 전체 패킷에서 헤더가 차지하는 비율이 상대적으로 작다. 
   - 대역폭을 효율적으로 사용할 수 있다. 
   - 전송 요청 횟수가 상대적으로 적어 CPU 사용량이 더 낮을 것이다.
   - ACK 패킷 수가 상대적으로 적어진다. 
   - IP 파편화가 발생할 가능성이 상대적으로 높다. 이는 중간 노드들의 상태에 따라 달라진다.
   - 파편화가 발생할 경우, 패킷이 많아지므로 혼잡 제어가 작동할 확률이 높아져 느려질 수 있다.
   - 패킷이 손실될 경우 재전송해야 하는 데이터의 크기가 커진다. 즉, 한번 손실될 때의 타격이 커진다.

크지도, 작지도 않은 적절한 값이 최소한의 전송 속도를 보여줄 것으로 예상된다. 

실제 실험을 통해 해당 값이 어느 정도인지 알아보자. 

### 변인 통제 - 파일 입출력 

만약, 테스트를 위한 데이터를 디스크에서 로드할 경우, 
파일 입출력 속도가 실험 결과에 영향을 미칠 수 있다. 

파일 입출력에 걸리는 속도가 네트워크 지연 차이보다 커서 
차이를 알기 어렵게 할 수 있는 것이다. 

TCP 실험에서는 **단순히 전송 속도**만 보면 된다. 
이미 TCP 자체가 신뢰성을 보장해주기 때문에 **파일 내용은 상관이 없다.** 
고려해야 할것은 전송한 데이터의 바이트 수와 전송 속도이다. 

따라서 TCP 실험에 한해서는 테스트 데이터를 파일에서 로드하는 것이 아닌, 
직접 메모리에 있는 임의의 데이터(0~255의 숫자와 같은)를 바이트 수만 맞춰서 
전송한다. 

### TCP 클라이언트 - 설계 

클라이언트의 흐름은 다음과 같다. 

1. 전송할 단위 크기 설정
   - 실험에서의 "변수"에 해당한다. 해당 값이 변함에 따라 속도의 차이가 얼마나 나는지 측정해야 한다.

2. 데이터 로드
   - 버퍼에 담긴 0~255의 숫자를 반복해서 전송할 것이다. (`new byte[65535]`)

3. 서버와 연결
   - TCP 소켓을 사용해서 TCP 서버에 연결한다.

4. 데이터 전송 후 시간 측정
   - 전송할 단위 크기별로 3번씩 반복한다.
   - 전송하기 직전에 시작 시간을 기록한다. (`System.nanoTime()`, `System.currentTimeMillis()` 등)
   - 단위 크기만큼 데이터를 읽어서 서버로 전송한다.
        - 전송 완료 시, 전송 완료 시간을 기록한다.
        - (완료 시간 - 시작 시간)을 계산해서 데이터 크기 단위와 계산한 시간을 `List`에 `record` 형태로 기록한다.

5. 모든 과정이 완료되면, 실험 결과를 `CSV`파일에 기록한다. 


### TCP 서버 - 설계 

1. TCP 서버 소켓을 bind 한다.
   - 지정된 포트로 소켓을 연다.

2. 클라이언트가 연결 요청을 하면 수락한다.

3. 데이터를 받는다.
   - 데이터를 받고, 받은 데이터의 바이트 수를 합산한다. (받은 데이터는 필요없으니 버린다.)

4. 파일 전송이 완료되면, 실험 결과를 `CSV` 파일에 기록한다.


### TCP 실험 프로그램 설계 과정 (계획, 기록) 

먼저 사용할 Java 모듈들에 대해 숙지하자. 

먼저 소켓 통신이므로 `ServerSocket`과 `Socket`을 사용한다. (실험이므로, 간단한 IO 기반으로 한다. NIO 기반은 단순 실험으로는 과하다.)

[Java ServerSocket 공식 문서](https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html)

[Java Socket 공식 문서](https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html)

그리고 파일 입출력을 위한 `FileInputStream`, `BufferedWriter` 등의 입출력 관련 스트림과 보조 스트림을 사용한다. 

또한 파일로 결과를 저장하기 위해 `record`를 적극 활용한다. 

[Java record 업데이트 문서](https://docs.oracle.com/en/java/javase/14/language/records.html#GUID-6699E26F-4A9B-4393-A08B-1E47D4B2D263)

일단은 클라이언트와 서버 각각 `main` 메소드를 가진 단일 클래스 구조로 한다. 
아직은 단순한 실험이기 때문이다. **나중에 필요하다면 클래스로 분리하고 멀티 스레딩을 도입한다.(스레드 풀 등)**

### TCP 클라이언트 - 제작 

(실제 코드는 리포지토리의 `TcpClient.java`를 참조바란다.)

`TestUtils`에 정의한 `getSocketAddressFromStdIn()` 메소드를 사용하여 
사용자로부터 접속할 서버의 소켓 정보를 입력받는다. 이는 여러 실험 환경에서 테스트할 때의 
편의성을 위함이다. 

마찬가지로 `TestUtils`의 `getDataSizes()`를 사용하여 실험의 "변수"에 해당하는 
데이터 단위들을 `List`로 받아온다. 기본적으로 `{500, 1000, 2000, ..., 65535}`의 값으로 구성되어 있다. 
만약, 단위를 변경해야 한다면 해당 메소드를 수정하면 될 것이다. 

실험 결과를 저장할 `List`를 `TestRecord` 타입으로 선언한다. 

이후, 실험 로직은 크게 아래와 같은 과정으로 실행된다. 

1. 데이터 단위 `List`에 대해 반복
   1. 시간 측정 시작 (`Timer` 사용)
   2. 서버와 연결 후, 출력 스트림을 받아옴. 이후 보낸 바이트 수와 총 바이트 수가 같을 때까지 반복
      1. 데이터 단위 만큼 보낼 바이트 수 설정 
      2. 출력 스트림에 보낼 바이트 수만큼 `buffer` 읽어서 `write` 
      3. 보낸 바이트 수 누적 
   3. 출력 스트림 닫아서 연결 종료 신호를 보냄 (`shutdownOutput()`)
   4. 시간 측정 종료 후, `TestRecord` 타입으로 `List`에 저장 
2. 실험 완료 후, `CsvWriter`로 실험 결과 `CSV` 파일로 출력 

### TCP 서버 - 제작 

(실제 코드는 리포지토리의 `TcpServer.java`를 참조바란다.)

먼저, 서버의 포트를 설정한다. 일단 `5000`번으로 설정했다. 

입력을 대기하다가, 콘솔에 `q`나 `Q`를 입력받으면 
서버 소켓을 강제로 닫아서 클라이언트 연결 대기(`accept`)에서 
예외가 발생하게 하여 강제로 서버를 종료하게 하는 스레드를 만들어서 실행한다. 

서버는 기본적으로 클라이언트의 접속을 대기하는 무한루프이므로 
안정적으로 종료할 방법이 필요하기 때문이다. 

강제 종료를 하게 되면 파일에 결과를 작성하는 것이 불가능해진다. 

실험 결과를 저장할 `List`를 `TcpClient`에서 만든 것과 
다른 `TestRecord` 타입으로 선언한다. 

이후, 서버는 아래와 같은 과정으로 실행 된다. 

1. 서버 소켓을 연다. 
2. 플래그가 종료로 바뀌거나, 예외가 발생 할 때까지 반복
   1. 클라이언트가 연결을 요청할때까지 기다린다. (블로킹). 연결되면 입력 스트림을 받아온다.
      1. 이때, `q`가 입력되면 소켓이 닫혀 예외가 발생, 루프를 빠져나간다.
   2. 시간 측정을 시작한다.
   3. 더 이상 수신할 데이터가 없을 때까지 `buffer`에 `read`한 후, 읽은 바이트 수를 누적한다.
   4. 시간 측정을 종료 후, `TestRecord` 타입으로 `List`에 저장한다. 
   5. 전송이 완료 되면 해당 클라이언트 소켓을 닫는다. 
3. 서버가 종료되면 실험 결과를 `CsvWriter`로 `CSV`파일로 출력한다. (`finally`)

### 로컬에서의 테스트 

제대로 작동하는 지 확인하기 위해 로컬 환경에서 테스트 해본다. 

클라이언트 측에서는 결과 파일(`testResult_client.csv`)는 아래와 같이 출력되었다. 

```csv
Data size,Elapsed Time,Total Bytes
500,1692,1073741824
1000,1665,1073741824
2000,1636,1073741824
4000,1611,1073741824
8000,1619,1073741824
16000,882,1073741824
32000,530,1073741824
64000,385,1073741824
65535,414,1073741824
```

서버측에서의 결과 파일(`testResult_server.csv`)는 아래와 같이 출력되었다. 

```csv
Received At,Elapsed Time,Total Bytes
2024-12-02T00:45:59.664175100,1688,1073741824
2024-12-02T00:46:01.321175300,1648,1073741824
2024-12-02T00:46:02.958175100,1636,1073741824
2024-12-02T00:46:04.569174200,1610,1073741824
2024-12-02T00:46:06.188174100,1618,1073741824
2024-12-02T00:46:07.071204600,882,1073741824
2024-12-02T00:46:07.602206700,530,1073741824
2024-12-02T00:46:07.988175800,385,1073741824
2024-12-02T00:46:08.402175500,413,1073741824
```












